"""move component_name to child table

Revision ID: 0032eb5e60f5
Revises: e421e7a9c8e5
Create Date: 2025-11-13 05:37:52.343043

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0032eb5e60f5'
down_revision: Union[str, Sequence[str], None] = 'e421e7a9c8e5'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    op.execute("DROP MATERIALIZED VIEW IF EXISTS recipe_ingredient_flattened;")

    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('countable_ingredients', sa.Column('component_name', sa.String(), nullable=False))
    op.create_unique_constraint(None, 'countable_ingredients', ['component_name'])
    op.drop_constraint(op.f('recipe_components_component_name_key'), 'recipe_components', type_='unique')
    op.drop_column('recipe_components', 'component_name')
    op.add_column('recipes', sa.Column('component_name', sa.String(), nullable=False))
    op.create_unique_constraint(None, 'recipes', ['component_name'])
    op.add_column('uncountable_ingredients', sa.Column('component_name', sa.String(), nullable=False))
    op.create_unique_constraint('unique_uncountable_ingredient', 'uncountable_ingredients', ['component_name', 'uc_measurement_unit'])
    # ### end Alembic commands ###

    op.execute("""
            CREATE MATERIALIZED VIEW recipe_ingredient_flattened AS
            WITH RECURSIVE recipe_expansion AS (
                -- Base case: Lấy tất cả components trực tiếp từ recipes
                SELECT 
                    cl.recipe_id,
                    r.component_name AS recipe_name,
                    cl.component_id,
                    COALESCE(
                        ci.component_name,
                        uci.component_name,
                        sr.component_name
                    ) AS component_name,
                    rc_component.type AS component_type,
                    cl.quantity,
                    r.default_servings,
                    cl.quantity AS adjusted_quantity,
                    COALESCE(
                        ci.c_measurement_unit::text,
                        uci.uc_measurement_unit::text
                    ) AS measurement_unit,
                    1 AS level
                FROM component_lists cl
                INNER JOIN recipe_components rc_recipe ON cl.recipe_id = rc_recipe.component_id
                INNER JOIN recipes r ON rc_recipe.component_id = r.component_id
                INNER JOIN recipe_components rc_component ON cl.component_id = rc_component.component_id
                LEFT JOIN recipes sr ON cl.component_id = sr.component_id
                LEFT JOIN countable_ingredients ci ON cl.component_id = ci.component_id
                LEFT JOIN uncountable_ingredients uci ON cl.component_id = uci.component_id
                WHERE rc_recipe.type = 'recipe'

                UNION ALL

                -- Recursive case: mở rộng sub-recipes
                SELECT 
                    re.recipe_id,
                    re.recipe_name,
                    cl.component_id,
                    COALESCE(
                        ci.component_name,
                        uci.component_name,
                        sr.component_name
                    ) AS component_name,
                    rc.type AS component_type,
                    cl.quantity AS original_quantity,
                    COALESCE(sr.default_servings, 1) AS default_servings,
                    CASE 
                        WHEN COALESCE(sr.default_servings, 1) > 0 THEN
                            re.adjusted_quantity * (cl.quantity / COALESCE(sr.default_servings, 1)::float)
                        ELSE 
                            re.adjusted_quantity * cl.quantity
                    END AS adjusted_quantity,
                    COALESCE(
                        ci.c_measurement_unit::text,
                        uci.uc_measurement_unit::text
                    ) AS measurement_unit,
                    re.level + 1
                FROM recipe_expansion re
                INNER JOIN component_lists cl ON re.component_id = cl.recipe_id
                INNER JOIN recipe_components rc ON cl.component_id = rc.component_id
                LEFT JOIN recipes sr ON cl.component_id = sr.component_id
                LEFT JOIN countable_ingredients ci ON cl.component_id = ci.component_id
                LEFT JOIN uncountable_ingredients uci ON cl.component_id = uci.component_id
                WHERE re.component_type = 'recipe'
                AND re.level < 10
            ),
            ingredient_totals AS (
                SELECT 
                    recipe_id,
                    recipe_name,
                    component_id,
                    component_name,
                    component_type,
                    measurement_unit,
                    SUM(adjusted_quantity) AS total_quantity
                FROM recipe_expansion
                WHERE component_type != 'recipe'
                GROUP BY recipe_id, recipe_name, component_id, component_name, component_type, measurement_unit
            )
            SELECT 
                recipe_id,
                recipe_name,
                jsonb_agg(
                    jsonb_build_object(
                        'component_id', component_id,
                        'component_name', component_name,
                        'quantity', total_quantity,
                        'unit', measurement_unit,
                        'type', component_type
                    ) ORDER BY component_name
                ) AS all_ingredients
            FROM ingredient_totals
            GROUP BY recipe_id, recipe_name
        """)


def downgrade() -> None:
    """Downgrade schema."""
    op.execute("DROP MATERIALIZED VIEW IF EXISTS recipe_ingredient_flattened;")

    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('unique_uncountable_ingredient', 'uncountable_ingredients', type_='unique')
    op.drop_column('uncountable_ingredients', 'component_name')
    op.drop_constraint(None, 'recipes', type_='unique')
    op.drop_column('recipes', 'component_name')
    op.add_column('recipe_components', sa.Column('component_name', sa.VARCHAR(), autoincrement=False, nullable=False))
    op.create_unique_constraint(op.f('recipe_components_component_name_key'), 'recipe_components', ['component_name'], postgresql_nulls_not_distinct=False)
    op.drop_constraint(None, 'countable_ingredients', type_='unique')
    op.drop_column('countable_ingredients', 'component_name')
    # ### end Alembic commands ###